<!DOCTYPE html>
<html>
<head>
	<title>Interactive Computer Graphics</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://csc.lsu.edu/~kooima/MathJax.js"></script>
	<script type="text/javascript" src="../script.js"></script>
</head>
<body>
	<h1>Shading</h1>

	<p>To render our geometry and take advantage of our normals, we require a shader that implements the <a href="../05-lighting/lighting-5.html">lighting equation</a>.</p>

	<p>The <em>uniforms</em> configure the transformation matrices and the lighting parameters. The <em>attributes</em> configure vertices. The <em>varyings</em> define the values to be interpolated by the rasterizer. <em>Pay close attention to their types</em>.</p>

	<figure class="pseudocode" id="vertex_shader">
		&#x3008;Vertex Shader&#x3009; &equiv;<br>
		&emsp;&emsp;<code>uniform</code> <code>mat4</code> <i>projectionMatrix</i><br>
		&emsp;&emsp;<code>uniform</code> <code>mat4</code> <i>modelMatrix</i><br>
		&emsp;&emsp;<code>uniform</code> <code>vec3</code> <i>lightDirection</i><br>
		&emsp;&emsp;<code>uniform</code> <code>vec3</code> <i>lightColor</i><br>
		&emsp;&emsp;<code>uniform</code> <code>vec3</code> <i>objectColor</i><br>
		<br>
		&emsp;&emsp;<code>attribute</code> <code>vec4</code> <i>vertexPosition</i><br>
		&emsp;&emsp;<code>attribute</code> <code>vec3</code> <i>vertexNormal</i><br>
		<br>
		&emsp;&emsp;<code>varying mediump</code> <code>vec3</code> <i>fragmentColor</i><br>
	</figure>

	<p>Here is the pseudocode of a vertex shader that implements the lighting equation. Filling in the types of the various <a href="../05-lighting/lighting-2.html">intermediate values</a> (<b>p</b>, <b>n</b>, <b>l</b>, <b>v</b>, <b>h</b>, <i>d</i>, and <i>s</i>) is left as an exercise for the reader.</p>

	<figure class="pseudocode">
		&emsp;&emsp;<b>function</b> main()<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><b>p</b></span> &larr; <i>modelMatrix</i> &middot; <i>vertexPosition</i><br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><b>n</b></span> &larr; <code>normalize</code>(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>vertexNormal</i>)<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><b>l</b></span> &larr; <code>normalize</code>(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>lightDirection</i>)<br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><b>v</b></span> &larr; <code>normalize</code>(<code>vec3</code>(&minus;<b>p</b>))<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><b>h</b></span> &larr; <code>normalize</code>(<b>v</b> + <b>l</b>)<br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><i>d</i></span> &larr; <code>max</code>(<b>n</b> &middot; <b>l</b>, 0)<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:1em"><i>s</i></span> &larr; <code>max</code>(<b>n</b> &middot; <b>h</b>, 0)<sup>100</sup><br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:6em"><i>fragmentColor</i></span> &larr; <i>lightColor</i> &middot; (<i>objectColor</i> &middot; <i>d</i> + <i>s</i>)<br>
		&emsp;&emsp;&emsp;&emsp;<span style="width:6em"><code>gl_Position</code></span> &larr; <i>projectionMatrix</i> &middot; <i>modelMatrix</i> &middot; <i>vertexPosition</i><br>
	</figure>

	<p>Here is the pseudocode of a fragment shader compatible with this vertex shader. It receives the varying value interpolated by the rasterizer and writes it to the frame buffer with an opaque alpha value.</p>

	<figure class="pseudocode" id="fragment_shader">
		&#x3008;Fragment Shader&#x3009; &equiv;<br>
		&emsp;&emsp;<code>varying mediump vec3</code> <i>fragmentColor</i><br>
		&emsp;&emsp;<b>function</b> main()<br>
		&emsp;&emsp;&emsp;&emsp;<code>gl_FragColor</code> &larr; <code>vec4</code>(<i>fragmentColor</i>, 1.0);<br>
	</figure>

	<h2>Shader Initialization</h2>

	<p>On the application side, we set up to render using this shader as follows.</p>

	<p>First, gather the source code strings of the GLSL shaders and pass them to the textbook's <code>initShaders</code> procedure. This procedure stores the <em>program object</em> in <code>gl.program</code>.</p>

	<figure class="pseudocode" id="initialization">
		&#x3008;Shader Initialization&#x3009; &equiv;<br>
		&emsp;&emsp;<code>initShaders</code>(<code>gl</code>,<br>
		&emsp;&emsp;&emsp;&emsp;<code>document.getElementById</code>(&ldquo;fragmentShader&rdquo;).<code>text</code>,<br>
		&emsp;&emsp;&emsp;&emsp;<code>document.getElementById</code>(&ldquo;vertexShader&rdquo;).<code>text</code>);<br>
	</figure>

	<p>We'll need to know the <em>locations</em> of the shader uniforms to give them values, Since we'll want to be able to set uniform values from anywhere in the code, such as in the draw function, their locations should be stored globally.</p>

	<figure class="pseudocode">
		&emsp;&emsp;<span style="width:10.5em"><i>projectionMatrixLocation</i></span> &larr; <code class="small">gl.getUniformLocation</code>(<code class="small">gl.program</code>, &ldquo;projectionMatrix&rdquo;);</code><br>
		&emsp;&emsp;<span style="width:10.5em"><i>modelMatrixLocation</i></span>      &larr; <code class="small">gl.getUniformLocation</code>(<code class="small">gl.program</code>, &ldquo;modelMatrix&rdquo;);</code><br>
		&emsp;&emsp;<span style="width:10.5em"><i>lightDirectionLocation</i></span>   &larr; <code class="small">gl.getUniformLocation</code>(<code class="small">gl.program</code>, &ldquo;lightDirection&rdquo;);</code><br>
		&emsp;&emsp;<span style="width:10.5em"><i>lightColorLocation</i></span>       &larr; <code class="small">gl.getUniformLocation</code>(<code class="small">gl.program</code>, &ldquo;lightColor&rdquo;);</code><br>
		&emsp;&emsp;<span style="width:10.5em"><i>objectColorLocation</i></span>      &larr; <code class="small">gl.getUniformLocation</code>(<code class="small">gl.program</code>, &ldquo;objectColor&rdquo;);</code><br>
	</figure>

	<nav>
		<a id="prev" href="viewer-normal.html"></a>
		<a id="home" href="../index.html"></a>
		<a id="next" href="viewer-buffers.html"></a>
	</nav>
</body>
</html>
