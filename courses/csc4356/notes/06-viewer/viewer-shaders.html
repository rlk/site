<!DOCTYPE html>
<html>
<head>
	<title>Interactive Computer Graphics</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://csc.lsu.edu/~kooima/MathJax.js"></script>
	<script type="text/javascript" src="../script.js"></script>
</head>
<body>
	<h1>Shading</h1>

	<p>To render our geometry and take advantage of our normal vectors, we require a shader that implements the <a href="../05-lighting/lighting-5.html">lighting equation</a>.</p>

	<p>The <em>uniforms</em> configure the transformation matrices and the lighting parameters. The <em>attributes</em> configure vertices. The <em>varyings</em> define the values to be interpolated by the rasterizer. <em>Pay close attention to their types</em>.</p>

	<figure class="pseudocode" id="vertex_shader">
		&#x3008;Vertex Shader&#x3009; &equiv;<br>
		<table style="margin-left:2em">
			<tr><td><code>uniform&nbsp;</code></td><td><code>mat4&nbsp;</code></td><td><i>projectionMatrix</i></td></tr>
			<tr><td><code>uniform&nbsp;</code></td><td><code>mat4&nbsp;</code></td><td><i>modelMatrix</i></td></tr>
			<tr><td><code>uniform&nbsp;</code></td><td><code>vec3&nbsp;</code></td><td><i>lightDirection</i></td></tr>
			<tr><td><code>uniform&nbsp;</code></td><td><code>vec3&nbsp;</code></td><td><i>lightColor</i></td></tr>
			<tr><td><code>uniform&nbsp;</code></td><td><code>vec3&nbsp;</code></td><td><i>objectColor</i></td></tr>
			<tr><td>&nbsp;</td></tr>
			<tr><td><code>attribute&nbsp;</code></td><td><code>vec4&nbsp;</code></td><td><i>vertexPosition</i></td></tr>
			<tr><td><code>attribute&nbsp;</code></td><td><code>vec3&nbsp;</code></td><td><i>vertexNormal</i></td></tr>
			<tr><td>&nbsp;</td></tr>
			<tr><td><code>varying mediump&nbsp;</code></td><td><code>vec3&nbsp;</code></td><td><i>fragmentColor</i></td></tr>
		</table>
	</figure>

	<p>Here is the pseudocode of a vertex shader that implements the lighting equation. Filling in the types of the various <a href="../05-lighting/lighting-2.html">intermediate values</a> ($\V{p}$, $\V{n}$, $\V{l}$, $\V{v}$, $\V{h}$, <i>d</i>, and <i>s</i>) is left as an exercise for the reader.</p>

	<figure class="pseudocode">
		&emsp;&emsp;<b>function</b> main()<br>
		<table style="margin-left:4em">
			<tr><td>$\V{p}$</td><td>&nbsp;&larr;&nbsp;</td><td><i>modelMatrix</i> &middot; <i>vertexPosition</i></td></tr>
			<tr><td>$\V{n}$</td><td>&nbsp;&larr;&nbsp;</td><td>normalize(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>vertexNormal</i>)</td></tr>
			<tr><td>$\V{l}$</td><td>&nbsp;&larr;&nbsp;</td><td>normalize(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>lightDirection</i>)</td></tr>
			<tr><td>&nbsp;</td></tr>
			<tr><td>$\V{v}$</td><td>&nbsp;&larr;&nbsp;</td><td>normalize(<code>vec3</code>($-\V{p}$))</td></tr>
			<tr><td>$\V{h}$</td><td>&nbsp;&larr;&nbsp;</td><td>normalize($\V{v} + \V{l}$)</td></tr>
			<tr><td>&nbsp;</td></tr>
			<tr><td><i>d</i></td><td>&nbsp;&larr;&nbsp;</td><td><code>max</code>($\V{n}\cdot\V{l}$, 0)</td></tr>
			<tr><td><i>s</i></td><td>&nbsp;&larr;&nbsp;</td><td><code>max</code>($\V{n}\cdot\V{h}$, 0)<sup>100</sup></td></tr>
			<tr><td>&nbsp;</td></tr>
		</table>
		<table style="margin-left:4em">
			<tr><td><i>fragmentColor</i></td><td>&nbsp;&larr;&nbsp;</td><td><i>lightColor</i> &middot; (<i>objectColor</i> &middot; <i>d</i> + <i>s</i>)</td></tr>
			<tr></tr>
			<tr><td><code>gl_Position</code></td><td>&nbsp;&larr;&nbsp;</td><td>projectionMatrix &middot; modelMatrix &middot; vertexPosition</td></tr>
		</table>
	</figure>

	<p>Here is the pseudocode of a fragment shader compatible with this vertex shader. It receives the varying value interpolated by the rasterizer and writes it to the frame buffer with an alpha value of one.</p>

	<figure class="pseudocode" id="fragment_shader">
		&#x3008;Fragment Shader&#x3009; &equiv;<br>
		&emsp;&emsp;<code>varying mediump vec3</code> <i>fragmentColor</i><br>
		&emsp;&emsp;<b>function</b> main()<br>
		&emsp;&emsp;&emsp;&emsp;<code>gl_FragColor</code> &larr; <code>vec4</code>(<i>fragmentColor</i>, 1.0);<br>
	</figure>

	<h2>Shader Initialization</h2>

	<p>We gather the source code string of or GLSL shaders and pass them to the textbook's <code>initShaders</code> function. This stores the <em>program object</em> in <code>gl.program</code>.</p>

	<figure class="pseudocode" id="initialization">
		&#x3008;Shader Initialization&#x3009; &equiv;<br>
		<table style="margin-left:2em">
			<tr class="small"><td><code>initShaders(gl,</code></td><td>&nbsp;<code>document.getElementById('fragmentShader').text, </code></td></tr>
			<tr class="small"><td><code>               </code></td><td>&nbsp;<code>document.getElementById(  'vertexShader').text);</code></td></tr>
		</table>
	</figure>

	<p>We'll need to know the <em>locations</em> of the shader uniforms to give them values, Since we'll want to be able to set uniform values anywhere in the code, their locations should be stored globally.</p>

	<figure class="pseudocode">
		<table style="margin-left:2em">
			<tr class="small"><td><i>projectionMatrixLocation</i></td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'projectionMatrix');</code></td></tr>
			<tr class="small"><td><i>modelMatrixLocation</i>     </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'modelMatrix');</code></td></tr>
			<tr class="small"><td><i>lightDirectionLocation</i>  </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'lightDirection');</code></td></tr>
			<tr class="small"><td><i>lightColorLocation</i>      </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'lightColor');</code></td></tr>
			<tr class="small"><td><i>objectColorLocation</i>     </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'objectColor');</code></td></tr>
		</table>
	</figure>

	<nav>
		<a id="prev" href="viewer-normal.html"></a>
		<a id="home" href="../index.html"></a>
		<a id="next" href="viewer-buffers.html"></a>
	</nav>
</body>
</html>
