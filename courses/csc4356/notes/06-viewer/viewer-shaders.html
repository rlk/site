<!DOCTYPE html>
<html>
<head>
	<title>Interactive Computer Graphics</title>
	<link rel="stylesheet" type="text/css" href="../style.css" />
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://csc.lsu.edu/~kooima/MathJax.js"></script>
	<script type="text/javascript" src="../script.js"></script>
</head>
<body>
	<h1>Shading</h1>

	<p>To render our geometry and take advantage of our normal vectors, we require a shader that implements the <a href="../05-lighting/lighting-5.html">lighting equation</a>.</p>

	<p>The <em>uniforms</em> configure the transformation matrices and the lighting parameters. The <em>attributes</em> configure vertices. The <em>varyings</em> define the values to be interpolated by the rasterizer. <em>Pay close attention to their types</em>.</p>

	<figure class="pseudocode">
		&#x3008;Vertex Shader&#x3009; &equiv;<br>
		&emsp;&emsp;<code>uniform mat4</code> <i>projectionMatrix</i><br>
		&emsp;&emsp;<code>uniform mat4</code> <i>modelMatrix</i><br>
		&emsp;&emsp;<code>uniform vec3</code> <i>lightDirection</i><br>
		&emsp;&emsp;<code>uniform vec3</code> <i>lightColor</i><br>
		&emsp;&emsp;<code>uniform vec3</code> <i>objectColor</i><br>
		<br>
		&emsp;&emsp;<code>attribute vec4</code> <i>vertexPosition</i><br>
		&emsp;&emsp;<code>attribute vec3</code> <i>vertexNormal</i><br>
		<br>
		&emsp;&emsp;<code>varying mediump vec3</code> <i>fragmentColor</i><br>
	</figure>

	<p>Here is the pseudocode of a vertex shader that implements the lighting equation. Filling in the types of the various intermediate values ($\V{p}$, $\V{n}$, $\V{l}$, $\V{v}$, $\V{h}$, <i>d</i>, and <i>s</i>) is left as an exercise for the reader.</p>

	<figure class="pseudocode">
		&emsp;&emsp;<b>function</b> main()<br>
		&emsp;&emsp;&emsp;&emsp;$\V{p}$ &larr; <i>modelMatrix</i> &middot; <i>vertexPosition</i><br>
		&emsp;&emsp;&emsp;&emsp;$\V{n}$ &larr; normalize(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>vertexNormal</i>)<br>
		&emsp;&emsp;&emsp;&emsp;$\V{l}\,$ &larr; normalize(<code>mat3</code>(<i>modelMatrix</i>) &middot; <i>lightDirection</i>)<br>
		<br>
		&emsp;&emsp;&emsp;&emsp;$\V{v}$ &larr; normalize(<code>vec3</code>($-\V{p}$))<br>
		&emsp;&emsp;&emsp;&emsp;$\V{h}$ &larr; normalize($\V{v} + \V{l}$)<br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<i>d</i> &larr; <code>max</code>($\V{n}\cdot\V{l}$, 0)<br>
		&emsp;&emsp;&emsp;&emsp;<i>s</i> &larr; <code>max</code>($\V{n}\cdot\V{h}$, 0)<sup>100</sup><br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<i>fragmentColor</i> &larr; <i>lightColor</i> &middot; (<i>objectColor</i> &middot; <i>d</i> + <i>s</i>)<br>
		<br>
		&emsp;&emsp;&emsp;&emsp;<code>gl_Position</code> &larr; projectionMatrix &middot; modelMatrix &middot; vertexPosition<br>
  </figure>

  <p>Here is the pseudocode of a fragment shader compatible with this vertex shader. It receives the varying value interpolated by the rasterizer and writes it to the frame buffer with an alpha value of one.</p>

  <figure class="pseudocode">
		&#x3008;Fragment Shader&#x3009; &equiv;<br>
  	&emsp;&emsp;<code>varying mediump vec3</code> <i>fragmentColor</i><br>
  	&emsp;&emsp;<b>function</b> main()<br>
  	&emsp;&emsp;&emsp;&emsp;<code>gl_FragColor</code> &larr; <code>vec4</code>(<i>fragmentColor</i>, 1.0);<br>
  </figure>

	<h2>Shader Initialization</h2>

	<p>We gather the source code string of or GLSL shaders and pass them to the textbook's <code>initShaders</code> function. This stores the <em>program object</em> in <code>gl.program</code>.</p>

	<figure class="pseudocode" id="initialization">
		<table style="margin-left:2em">
			<tr class="small"><td><code>initShaders(gl,</code></td><td>&nbsp;<code>document.getElementById('fragmentShader').text, </code></td></tr>
      <tr class="small"><td><code>               </code></td><td>&nbsp;<code>document.getElementById(  'vertexShader').text);</code></td></tr>
		</table>
	</figure>

	<p>The lighting equation has several parameters defined as <em>uniform</em> variables. We'll need to know the <em>locations</em> of these uniforms to give the values, Since we'll want to be able to set uniform values anywhere in the code, their locations should be stored globally.</p>

	<figure class="pseudocode">
   	<table style="margin-left:2em">
	   	<tr class="small"><td><i>projectionMatrixLocation</i></td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'projectionMatrix');</code></td></tr>
	    <tr class="small"><td><i>modelMatrixLocation</i>     </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'modelMatrix');</code></td></tr>
	    <tr class="small"><td><i>lightDirectionLocation</i>  </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'lightDirection');</code></td></tr>
	    <tr class="small"><td><i>lightColorLocation</i>      </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'lightColor');</code></td></tr>
	    <tr class="small"><td><i>objectColorLocation</i>     </td><td>&nbsp;&larr;&nbsp;</td><td><code>gl.getUniformLocation(gl.program, 'objectColor');</code></td></tr>
    </table>
	</figure>

	<nav>
		<a id="prev" href="viewer-rendering.html"></a>
		<a id="home" href="../index.html"></a>
		<a id="next" href="viewer-elements.html"></a>
	</nav>
</body>
</html>
